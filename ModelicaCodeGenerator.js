/*globals define*/
/*eslint-env node, browser*/

/**
 * Generated by PluginGenerator 2.20.5 from webgme on Fri Jan 22 2021 10:29:34 GMT+0900 (���ѹα� ǥ�ؽ�).
 * A plugin that inherits from the PluginBase. To see source code documentation about available
 * properties and methods visit %host%/docs/source/PluginBase.html.
 */


// Require dependencies..
define([
    'plugin/PluginConfig',
    'text!./metadata.json',
    'plugin/PluginBase'
], function (
    PluginConfig,
    pluginMetadata,
    PluginBase) {
        'use strict';

        pluginMetadata = JSON.parse(pluginMetadata);

        /**
         * Initializes a new instance of ModelicaCodeGenerator.
         * @class
         * @augments {PluginBase}
         * @classdesc This class represents the plugin ModelicaCodeGenerator.
         * @constructor
         */
        function ModelicaCodeGenerator() {
            // Call base class' constructor.
            PluginBase.call(this);
            this.pluginMetadata = pluginMetadata;
        }

        /**
         * Metadata associated with the plugin. Contains id, name, version, description, icon, configStructure etc.
         * This is also available at the instance at this.pluginMetadata.
         * @type {object}
         */
        ModelicaCodeGenerator.metadata = pluginMetadata;

        // Prototypical inheritance from PluginBase.
        ModelicaCodeGenerator.prototype = Object.create(PluginBase.prototype);
        ModelicaCodeGenerator.prototype.constructor = ModelicaCodeGenerator;

        /**
         * Main function for the plugin to execute. This will perform the execution.
         * Notes:
         * - Always log with the provided logger.[error,warning,info,debug].
         * - Do NOT put any user interaction logic UI, etc. inside this method.
         * - callback always has to be called even if error happened.
         *
         * @param {function(Error|null, plugin.PluginResult)} callback - the result callback
         */
        ModelicaCodeGenerator.prototype.main = function (callback) {
            // Use this to access core, project, result, logger etc from PluginBase.
            var self = this,
                core = this.core,
                logger = this.logger,
                modelJson = {
                    name: '',
                    components: [],
                    connections: []
                },
                activeNode = this.activeNode;


            function atComponent(node) {
                var componentData = {
                    URI: '',
                    name: '',
                    parameters: {},
                    modifiers: ''
                };

                componentData.URI = core.getAttribute(node, 'ModelicaURI');
                componentData.name = core.getAttribute(node, 'name');

                core.getAttributeNames(node).forEach((attrName) => {
                    if (attrName !== 'name' && !core.getAttributeMeta(node, attrName).readonly) { // except for Node name and ModelicaURI
                        if (attrName === 'modifiers') {
                            componentData.modifiers = core.getAttribute(node, attrName) || '';
                        } else {
                            componentData.parameters[attrName] = core.getAttribute(node, attrName);
                        }
                    }
                });

                modelJson.components.push(componentData);

            }

            function atConnection(nodes, node) {
                var connData = {
                    src: '',
                    dst: ''
                };

                // Node is a connection node -> it should have two pointers src and dst.
                // The target of these are the two connected ports..
                var srcPath = core.getPointerPath(node, 'src');
                var dstPath = core.getPointerPath(node, 'dst');

                // In case there is no src or dst the connection is not wired and should be skipped..
                if (srcPath && dstPath) {
                    var srcNode = nodes[srcPath]; // Again we use the node-map to go from path to node..
                    var dstNode = nodes[dstPath];

                    var srcParent = core.getParent(srcNode); // Parents (and bases too) are always loaded for a node..
                    var dstParent = core.getParent(dstNode); // so no need to use the node-map here.

                    // To get the Modelica path to the port inside a component those names are concantented, e.g. Group.p.

                    connData.src = core.getAttribute(srcParent, 'name') + '.' + core.getAttribute(srcNode, 'name');
                    connData.dst = core.getAttribute(dstParent, 'name') + '.' + core.getAttribute(dstNode, 'name');

                    // (Interface ����) ��Ʈ�� �̸��� ���� ����
                    if (connData.src.slice(-1) == '.') {
                        connData.src = connData.src.slice(0, -1);
                    }
                    if (connData.dst.slice(-1) == '.') {
                        connData.dst = connData.dst.slice(0, -1);
                    }

                    modelJson.connections.push(connData);
                }
            }
            function substr_count(haystack, needle, offset, length) { // eslint-disable-line camelcase

                let cnt = 0
                haystack += ''
                needle += ''

                if (isNaN(offset)) {
                    offset = 0
                }
                if (isNaN(length)) {
                    length = 0
                }
                if (needle.length === 0) {
                    return false
                }
                offset--
                while ((offset = haystack.indexOf(needle, offset + 1)) !== -1) {
                    if (length > 0 && (offset + needle.length) > length) {
                        return false
                    }
                    cnt++
                }
                return cnt
            }

            function getMoFileContent() {
                var moFile = 'model ' + modelJson.name;
                const title = moFile;

                // Components

                modelJson.components
                    .sort((a, b) => {
                        if (a.URI > b.URI) {
                            return 1;
                        } else if (a.URI < b.URI) {
                            return -1;
                        } else if (a.name > b.name) {
                            return 1;
                        } else if (a.name < b.name) {
                            return -1;
                        }

                        return 0;
                    })


                    .forEach((data) => {
                        const params = Object.keys(data.parameters);

                        if (data.name === 'Medium') {
                            moFile = moFile.replace(title, title + '\n  ' + 'replaceable package Medium = ' + data.URI + ';\n');
                        } else if(data.name === 'system') {
                            moFile += '\n  inner ' + data.URI + ' ' + data.name;
                        } else {
                            moFile += '\n  ' + data.URI + ' ' + data.name;
                        }

                        if (params.length > 0) {

                            // Open bracket

                            moFile += '(';

                            params.map((p, idx) => {

                                // Add Parameters

                                if (p === 'Medium') {
                                    moFile += 'redeclare package Medium = ' + data.parameters[p] + ', ';
                                } else if (data.parameters[p] != '') {

                                    // Check unit
                                    if (data.parameters[p].indexOf('[') && data.parameters[p].indexOf(']') != -1) {

                                    }

                                    // Convert '-' into '.'
                                    if (p.indexOf('-') != -1) {
                                        moFile += p.slice(0, p.indexOf('-')) + '(' + p.slice(p.indexOf('-')+1) + '=' + data.parameters[p] + '), ';
                                    } else {
                                        moFile += p + '=' + data.parameters[p] + ', ';
                                    }
                                }

                                // Close bracket

                                if (idx === params.length - 1) {
                                    if (data.modifiers) {
                                        moFile += data.modifiers;
                                    } else if (idx == 0) {
                                        moFile = moFile.slice(0, -1);
                                    } else {
                                        moFile = moFile.slice(0, -2);
                                    }
                                }
                            });

                            moFile += ')';

                            // Check round brackets

                            if ((substr_count(moFile, '(') + substr_count(moFile, ')')) % 2 == 1) {
                                moFile = moFile.slice(0, -1);
                            }

                            moFile += ';';

                            // Check double semicolon

                            if (moFile.indexOf(';;') != -1){
                                moFile = moFile.slice(0, -1);
                            }

                        } else if (data.modifiers) {
                            moFile += `(${data.modifiers});`;
                        }

                    });

                moFile += '\nequation';

                // Connection

                modelJson.connections
                    .sort((a, b) => {
                        if (a.src > b.src) {
                            return 1;
                        } else if (a.src < b.src) {
                            return -1;
                        } else if (a.dst > b.dst) {
                            return 1;
                        } else if (a.dst < b.dst) {
                            return -1;
                        }

                        return 0;
                    })
                    .forEach((data) => {
                        moFile += '\n  connect(' + data.src + ', ' + data.dst + ');';
                    });

                moFile += '\nend ' + modelJson.name + ';';

                logger.info(moFile);

                return moFile;

            }


            // Preload the sub-tree from activeNode (all children from the system)
            self.loadNodeMap(this.activeNode)
                .then(function (nodes) {
                    var nodePath,
                        node;

                    for (nodePath in nodes) {
                        self.logger.info(self.core.getAttribute(nodes[nodePath], 'name'), 'has path', nodePath);
                    }

                    modelJson.name = core.getAttribute(activeNode, 'name');

                    // Get all the children paths of the activeNode
                    var childrenPaths = core.getChildrenPaths(activeNode);

                    for (var i = 0; i < childrenPaths.length; i += 1) {
                        node = nodes[childrenPaths[i]]; // Using the node-map loaded above..
                        if (self.isMetaTypeOf(node, self.META.Component)) {
                            atComponent(node);
                        } else if (self.isMetaTypeOf(node, self.META.Connection)) {
                            atConnection(nodes, node);
                        }
                    }

                    self.logger.info('Extracted data:\n', JSON.stringify(modelJson, null, 2));

                    var moFileContent = getMoFileContent();

                    // We'd like to add the file to the blob-storage
                    // the blobClient is available for the plugin and the method to use is putFile
                    // It's an asynchronous function that returns a promise.. So we chain it with the other promises..

                    // First argument  is the name of the file, second the content
                    return self.blobClient.putFile(modelJson.name + '.mo', moFileContent);
                })
                .then(function (metaHash) {
                    // Here the file has been added together with some metadata with name etc.
                    // Link it to the plugin result.

                    self.result.addArtifact(metaHash);
                    self.result.setSuccess(true);
                    callback(null, self.result);
                })
                .catch(function (err) {
                    // Result success is false at invocation.
                    self.logger.error(err.stack);
                    callback(err, self.result);
                });
        };

        return ModelicaCodeGenerator;
    });
